package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import android.annotation.SuppressLint;
import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
import com.qualcomm.robotcore.hardware.AnalogInput;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.CRServo;
// import org.openftc.apriltag.AprilTagDetection;
// import org.openftc.easyopencv.OpenCvCamera;
// import org.openftc.easyopencv.OpenCvCameraFactory;
// import org.openftc.easyopencv.OpenCvCameraRotation;
import java.util.ArrayList;

import org.firstinspires.ftc.teamcode.sussy.*;
@Autonomous
public class Auto_BlueBlue extends LinearOpMode {
    // OpenCvCamera camera;
    // AprilTagDetectionPipeline aprilTagDetectionPipeline;

    // static final double FEET_PER_METER = 3.28084;
    private DcMotorEx frontLeft;
    private DcMotorEx backLeft;
    private DcMotorEx frontRight;
    private DcMotorEx backRight;
    private DcMotorEx g;
    private CRServo thing;
    private ElapsedTime runtime = new ElapsedTime();
    
    final boolean left = true;
    final boolean right = false;
    final boolean forward = true;
    final boolean back = false;
    
    final int speed = 700;
    //  double fx = 578.272;
    // double fy = 578.272;
    // double cx = 402.145;
    // double cy = 221.506;

    // // UNITS ARE METERS
    // double tagSize = 0.044;// Default value: 0.166

    // int LEFT = 1;
    // int MIDDLE = 2;
    // int RIGHT = 3;

    // AprilTagDetection tagOfInterest = null;
    @Override public void runOpMode() {
        //// INIT
        //  int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier("cameraMonitorViewId", "id", hardwareMap.appContext.getPackageName());
        // camera = OpenCvCameraFactory.getInstance().createWebcam(hardwareMap.get(WebcamName.class, "Webcam 1"), cameraMonitorViewId);
        // aprilTagDetectionPipeline = new AprilTagDetectionPipeline(tagSize, fx, fy, cx, cy);
        frontLeft = hardwareMap.get(DcMotorEx.class, "motor1");
        backLeft = hardwareMap.get(DcMotorEx.class, "motor2");
        frontRight = hardwareMap.get(DcMotorEx.class, "motor3");
        backRight = hardwareMap.get(DcMotorEx.class, "motor4");
        g = hardwareMap.get(DcMotorEx.class, "g");
        thing = hardwareMap.get(CRServo.class, "thing");
        
        frontRight.setDirection(DcMotor.Direction.REVERSE);
        backRight.setDirection(DcMotor.Direction.REVERSE);
        
        resetEncoders();
        //// START
        waitForStart();
        // camera.setPipeline(aprilTagDetectionPipeline);
        // camera.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener() {
        //     @Override
        //     public void onOpened() {
        //         camera.startStreaming(800,448, OpenCvCameraRotation.UPRIGHT);
        //     }

        //     @Override
        //     public void onError(int errorCode) {
        //     }
        // });
        // telemetry.setMsTransmissionInterval(50);

         move(1200, forward, speed);
        sleep(2500);
        strafe(590, right, speed);
        sleep(1500);
        
       

  ExecutorService executor = Executors.newCachedThreadPool();
    executor.execute(new intake());
    sleep(2000);
                    g.setTargetPosition(650);
                g.setMode(DcMotorEx.RunMode.RUN_TO_POSITION);
                g.setVelocity(500);
            sleep(2000);
     move(170,forward,speed);
     sleep(1000);
     thing.setPower(-1);
            sleep(500);
         move(300,false,speed);
         sleep(1000);
    thing.setPower(0);
    strafe(620, left, speed);
    sleep(1000);
    move(2100, forward, speed);
    sleep(1500);
    turn(1350, left, speed);
    sleep(2500);
        
        
        // Stop motors from running to position
         frontLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        frontRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
          backLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
         backRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        // Telemetry
        while (opModeIsActive()) {
            //  ArrayList<AprilTagDetection> currentDetections = aprilTagDetectionPipeline.getLatestDetections();

            // if(currentDetections.size() != 0) {
            //     boolean tagFound = false;

            //     for(AprilTagDetection tag : currentDetections) {
            //         //// CHANGE FROM ORIGINAL
            //         //if(tag.id == ID_TAG_OF_INTEREST)
            //         if(tag.id == LEFT || tag.id == MIDDLE || tag.id == RIGHT) {
            //             tagOfInterest = tag;
            //             tagFound = true;
            //             break;
            //         }
            //     }

            //     if(tagFound) {
            //         telemetry.addLine("Tag of interest is in sight!\n\nLocation data:");
            //         tagToTelemetry(tagOfInterest);
            //     } else {
            //         telemetry.addLine("Don't see tag of interest :(");

            //         if(tagOfInterest == null) {
            //             telemetry.addLine("(The tag has never been seen)");
            //         } else {
            //             telemetry.addLine("\nBut we HAVE seen the tag before; last seen at:");
            //             tagToTelemetry(tagOfInterest);
            //         }
            //     }
            // } else {
            //     telemetry.addLine("Don't see tag of interest :(");

            //     if(tagOfInterest == null) {
            //         telemetry.addLine("(The tag has never been seen)");
            //     } else {
            //         telemetry.addLine("\nBut we HAVE seen the tag before; last seen at:");
            //         tagToTelemetry(tagOfInterest);
            //     }
            // }
            // telemetry.update();
            // sleep(20);
            telemetry.addData("Arm position", g.getCurrentPosition());
            telemetry.update();
        }
    }
    public void resetEncoders() {
        // Resets Encoders
        frontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        backLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        frontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        backRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
    }
    //  @SuppressLint("DefaultLocale")
    // void tagToTelemetry(AprilTagDetection detection) {
    //     telemetry.addLine("\nDetected tag ID: " + detection.id);
    //     telemetry.addLine(String.format("Translation X: %.2f feet", detection.pose.x*FEET_PER_METER));
    //     telemetry.addLine(String.format("Translation Y: %.2f feet", detection.pose.y*FEET_PER_METER));
    //     telemetry.addLine(String.format("Translation Z: %.2f feet", detection.pose.z*FEET_PER_METER));
    //     telemetry.addLine(String.format("Rotation Yaw: %.2f degrees", Math.toDegrees(detection.pose.yaw)));
    //     telemetry.addLine(String.format("Rotation Pitch: %.2f degrees", Math.toDegrees(detection.pose.pitch)));
    //     telemetry.addLine(String.format("Rotation Roll: %.2f degrees", Math.toDegrees(detection.pose.roll)));
    // }
    public void move(int ticks, boolean forwardOrBackward, int velocity) {
        resetEncoders();
        if (forwardOrBackward == true) {
        // Drive forwards if `forwardOrBackward` is true
            // Set target position
            frontLeft.setTargetPosition(-ticks);
            frontRight.setTargetPosition(-ticks);
            backLeft.setTargetPosition(-ticks);
            backRight.setTargetPosition(-ticks);
    
            // Set mode
            frontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            frontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            backLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            backRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    
            // Set velocity
            frontLeft.setVelocity(velocity);
            frontRight.setVelocity(velocity);
            backLeft.setVelocity(velocity);
            backRight.setVelocity(velocity);
        } else if (forwardOrBackward == false) {
        // Drive backwards if `forwardOrBackward` is false
            // Set target position
            frontLeft.setTargetPosition(ticks);
            frontRight.setTargetPosition(ticks);
            backLeft.setTargetPosition(ticks);
            backRight.setTargetPosition(ticks);
    
            // Set mode
            frontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            frontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            backLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            backRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    
            // Set velocity
            frontLeft.setVelocity(velocity);
            frontRight.setVelocity(velocity);
            backLeft.setVelocity(velocity);
            backRight.setVelocity(velocity);
        }

    }
    public void turn(int degrees, boolean leftOrRight, int velocity) {
        resetEncoders();
        if(leftOrRight == true) {
        // Drive left if `leftOrRight` is true
            // Set target position
            frontLeft.setTargetPosition(degrees);
            frontRight.setTargetPosition(-degrees);
            backLeft.setTargetPosition(degrees);
            backRight.setTargetPosition(-degrees);
    
            // Set mode
            frontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            frontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            backLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            backRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    
            // Set velocity
            frontLeft.setVelocity(velocity);
            frontRight.setVelocity(velocity);
            backLeft.setVelocity(velocity);
            backRight.setVelocity(velocity);
        } else if (leftOrRight == false) {
        // Drive right if `leftOrRight` is false
            // Set target position
            frontLeft.setTargetPosition(-degrees);
            frontRight.setTargetPosition(degrees);
            backLeft.setTargetPosition(-degrees);
            backRight.setTargetPosition(degrees);
    
            // Set mode
            frontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            frontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            backLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            backRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    
            // Set velocity
            frontLeft.setVelocity(velocity);
            frontRight.setVelocity(velocity);
            backLeft.setVelocity(velocity);
            backRight.setVelocity(velocity);
        }

    }
    public void strafe(int ticks, boolean leftOrRight, int velocity) {
        resetEncoders();
        if (leftOrRight == true) {
        // Strafe left if `leftOrRight` is true
            // Set target position
            frontLeft.setTargetPosition(ticks);
            frontRight.setTargetPosition(-ticks);
            backLeft.setTargetPosition(-ticks);
            backRight.setTargetPosition(ticks);
    
            // Set mode
            frontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            frontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            backLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            backRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    
            // Set velocity
            frontLeft.setVelocity(velocity);
            frontRight.setVelocity(velocity);
            backLeft.setVelocity(velocity);
            backRight.setVelocity(velocity);
        } else if (leftOrRight == false) {
        // Strafe right if `leftOrRight` is false
            // Set target position
            frontLeft.setTargetPosition(-ticks);
            frontRight.setTargetPosition(ticks);
            backLeft.setTargetPosition(ticks);
            backRight.setTargetPosition(-ticks);
    
            // Set mode
            frontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            frontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            backLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            backRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
    
            // Set velocity
            frontLeft.setVelocity(velocity);
            frontRight.setVelocity(velocity);
            backLeft.setVelocity(velocity);
            backRight.setVelocity(velocity);
        }
    }
    public void scoreLow() {
        resetEncoders();
        // Set target position
        thing.setPower(0.1);
        sleep(1000);
        g.setTargetPosition(280);
        g.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        g.setVelocity(600);
        sleep(1000);
        sleep(3000);
        thing.setPower(-0.1);
        sleep(1000);
    
        
        
        
    }
    public void scoreMedium() {
        resetEncoders();
        // Set target position
        thing.setPower(0.1);
        sleep(1000);
        g.setTargetPosition(700);
        g.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        g.setVelocity(600);
        sleep(1000);
        sleep(3000);
        thing.setPower(-0.1);
        sleep(1000);
    
        
        
        
    }
    private class intake implements Runnable
{
  public void run()
  {
    thing.setPower(1);
  }
}

}

// public class AprilTagAutonomous extends PineappleSomething {
    

//     // Lens intrinsics
//     // UNITS ARE PIXELS
//     // NOTE: this calibration is for the C920 webcam at 800x448.
//     // You will need to do your own calibration for other configurations!
   

//     @Override
//     public void runOpMode() {
       
//         frontLeft = hardwareMap.get(DcMotorEx.class, "motor1");
//         backLeft = hardwareMap.get(DcMotorEx.class, "motor2");
//         frontRight = hardwareMap.get(DcMotorEx.class, "motor3");
//         backRight = hardwareMap.get(DcMotorEx.class, "motor4");
//         g = hardwareMap.get(DcMotorEx.class, "g");
//         thing = hardwareMap.get(CRServo.class, "thing");
//         deeznuts = hardwareMap.get(AnalogInput.class, "deez2");
//         frontRight.setDirection(DcMotor.Direction.REVERSE);
//         backRight.setDirection(DcMotor.Direction.REVERSE);

        
//         /*
//          * The INIT-loop:
//          * This REPLACES waitForStart!
//          */
//         while (!isStarted() && !isStopRequested()) {
//             telemetry.addData("Potentiometer Voltage:", deeznuts.getVoltage());

           
//         }

//         /*
//          * The START command just came in: now work off the latest snapshot acquired
//          * during the init loop.
//          */

//         /* Update the telemetry */
//         if(tagOfInterest != null) {
//             telemetry.addLine("Tag snapshot:\n");
//             tagToTelemetry(tagOfInterest);
//             telemetry.update();
//         } else {
//             telemetry.addLine("No tag snapshot available, it was never sighted during the init loop :(");
//             telemetry.update();
//         }

//         /* Actually do something useful */
// //        if(tagOfInterest == null || tagOfInterest.id == LEFT) {
// //            //trajectory
// //        } else if (tagOfInterest.id == MIDDLE) {
// //            //trajectory
// //        } else {
// //            //trajectory
// //        }

//         //// AUTONOMOUS CODE HERE:
//         resetEncoders();
//         Score.executorFunc();
//         sleep(2000);
//         Score.low();
//         if (tagOfInterest.id == LEFT) {
//             Move.strafe(1400, left, 700);
//             sleep(2000);
//             Move.straight(1400, forward, 700);
//             sleep(2000);
//         } else if (tagOfInterest.id == MIDDLE) {
//             Move.straight(1400, forward, 700);
//             sleep(2000);
//         } else {
//             Move.strafe(800, right, 700);
//             sleep(1000);
//             Move.straight(200, forward, 400);
//             sleep(1000);
//             thing.setPower(-1);
//             sleep(1000);
//             thing.setPower(0);
//             Move.straight(200, back, 400);
//             sleep(500);
//             Move.strafe(800, left, 700);
//             sleep(1000);
//         }
//     }

   
// }

